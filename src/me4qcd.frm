*#include me4qcd.h # Declarations
#: Workspace 1G

*--#[ Declarations :
#include color.h

CF den, den2, num, GM, gm, sp,w;

* SUn.prc from color.h package
CF color,Wden;
S NF,NA;
S m,ep,I;


#define N "200";
#do i=1,`N'
I cj`i'=NA;
I cii`i'=NF;
I cie`i'=NF;
I cji`i'=NA;
I cje`i'=NA;
I mu`i'=m;
I mui`i'=m;
I mue`i'=m;
#enddo
Set cii:cii1,...,cii`N';
Set cie:cie1,...,cie`N';
Set cji:cji1,...,cji`N';
Set cje:cje1,...,cje`N';
Set mu:mu1,...,mu`N';
Set mui:mui1,...,mui`N';
Set mue:mue1,...,mue`N';

CF e,i, a,b,c,d, te,ti;

S  Ca,Cf,Na,Tf,nf;

* QGRAF variables
S  n,eps;
CF amp,ampx;
CF Vggg,Vgggg,vgggg,Vqqg,Vqqa;
CF Pu, Pd, Pg, Pax, Pux,PUx, Pdx,PDx, Pgx;
CF Fa, Fu,FU, Fd,FD, Fg;

Dimension m;
#do i=0,99
I v`i'=m;
I s`i';
#enddo

V k,k1,...,k9;
set ks: k1,...,k9;
V l1,...,l9;
V r1,...,r9;
V p,p1,...,p9;
V q;

S ex,ex1,ex2,ex3;
S n1,...,n4;
*--#] Declarations :

#define DEBUG

* ------------------------------------------------------------------------------
*                                 1. Read Amplitudes
* ------------------------------------------------------------------------------

* Here, AMP and AMPx are generated with `drqgraf' with the same <in>_<out>, but one
* with '-x' option used. (That is with <in> and <out> exchanged, e.g., AMPx.in = AMP.out).

* Read AMP
#include `AMP' # Declarations
L AMP =
#do i = 1,$n
  + amp(`i')*(
  #include `AMP' # d`i'
  )
#enddo
;
.sort

* Read AMPx
#include `AMPx' # Declarations
Skip;
L AMPx =
#do i = 1,$n
  + ampx(`i')*(
  #include `AMPx' # d`i'
  )
#enddo
;
* Since AMP and AMPx are generated by QGRAF independently their indices overlap.
* That makes impossible to restore a propper order of propagators when
* both are combined into ME2. We fix this by bumping indices in AMPx.
#define DI "100"
#do F={Fa, Fu, FU, Fd, FD, Fg} 
id `F'(n1?neg_,k1?) = `F'(n1-`DI',k1);
#enddo
#do V={Vqqa, Vqqg, Vggg} 
id `V'(n1?pos_,k1?, n2?,k2?, n3?,k3?) = `V'(n1+`DI',k1, n2,k2, n3,k3);
id `V'(n1?,k1?, n2?pos_,k2?, n3?,k3?) = `V'(n1,k1, n2+`DI',k2, n3,k3);
id `V'(n1?,k1?, n2?,k2?, n3?pos_,k3?) = `V'(n1,k1, n2,k2, n3+`DI',k3);
id `V'(n1?neg_,k1?, n2?,k2?, n3?,k3?) = `V'(n1-`DI',k1, n2,k2, n3,k3);
id `V'(n1?,k1?, n2?neg_,k2?, n3?,k3?) = `V'(n1,k1, n2-`DI',k2, n3,k3);
id `V'(n1?,k1?, n2?,k2?, n3?neg_,k3?) = `V'(n1,k1, n2,k2, n3-`DI',k3);
#enddo
id Vgggg(n1?pos_,k1?, n2?,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1+`DI',k1, n2,k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?pos_,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1,k1, n2+`DI',k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?pos_,k3?, n4?,k4?) = Vgggg(n1,k1, n2,k2, n3+`DI',k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?,k3?, n4?pos_,k4?) = Vgggg(n1,k1, n2,k2, n3,k3, n4+`DI',k4);
id Vgggg(n1?neg_,k1?, n2?,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1-`DI',k1, n2,k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?neg_,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1,k1, n2-`DI',k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?neg_,k3?, n4?,k4?) = Vgggg(n1,k1, n2,k2, n3-`DI',k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?,k3?, n4?neg_,k4?) = Vgggg(n1,k1, n2,k2, n3,k3, n4-`DI',k4);
#do P={Pu, Pd, Pg} 
id `P'(n1?pos_, n2?,k1?) = `P'(n1+`DI',n2,k1);
id `P'(n1?, n2?pos_,k1?) = `P'(n1,n2+`DI',k1);
#enddo

* ------------------------------------------------------------------------------
*                             1.1 Complex Conjugate
* ------------------------------------------------------------------------------

#do P={Pg} 
id `P'(?args) = -`P'(?args);
#enddo
#do V={Vggg,Vgggg} 
id `V'(?args) = -`V'(?args);
#enddo
.sort

*Print +ss;
*.end


* ------------------------------------------------------------------------------
*                                 2. Build ME2
* ------------------------------------------------------------------------------

L ME2 = AMP*AMPx;
id amp(ex1?)*ampx(ex2?) = amp(ex1,ex2);
*id amp(ex1?)*ampx(ex2?) = 1;
.sort
Drop AMP,AMPx;


* Connect external lines
#do X={a,u,d,g} 
id F`X'(n1?even_,k1?)*F`X'(n2?odd_,k1?) = P`X'x(n1,n2,k1);
#enddo
#do X={U,D} 
id F`X'(n1?even_,k1?)*F`X'(n2?odd_,k1?) = P`X'x(n2,n1,-k1);
#enddo
id PUx(?args) = Pux(?args);
id PDx(?args) = Pdx(?args);
.sort

* Make all indices positive
#do P={Pu, Pd, Pg, Pax, Pux, Pdx, Pgx} 
id `P'(n1?pos_,n2?,k1?) = `P'(i(n1),n2,k1);
id `P'(n1?neg_,n2?,k1?) = `P'(e(-n1),n2,k1);
id `P'(n1?,n2?pos_,k1?) = `P'(n1,i(n2),k1);
id `P'(n1?,n2?neg_,k1?) = `P'(n1,e(-n2),k1);
#enddo
#do V={Vqqa, Vqqg, Vggg} 
id `V'(n1?pos_,k1?, n2?,k2?, n3?,k3?) = `V'(i(n1),k1, n2,k2, n3,k3);
id `V'(n1?,k1?, n2?pos_,k2?, n3?,k3?) = `V'(n1,k1, i(n2),k2, n3,k3);
id `V'(n1?,k1?, n2?,k2?, n3?pos_,k3?) = `V'(n1,k1, n2,k2, i(n3),k3);
id `V'(n1?neg_,k1?, n2?,k2?, n3?,k3?) = `V'(e(-n1),k1, n2,k2, n3,k3);
id `V'(n1?,k1?, n2?neg_,k2?, n3?,k3?) = `V'(n1,k1, e(-n2),k2, n3,k3);
id `V'(n1?,k1?, n2?,k2?, n3?neg_,k3?) = `V'(n1,k1, n2,k2, e(-n3),k3);
#enddo
id Vgggg(n1?neg_,k1?, n2?,k2?, n3?,k3?, n4?,k4?) = Vgggg(e(-n1),k1, n2,k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?neg_,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1,k1, e(-n2),k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?neg_,k3?, n4?,k4?) = Vgggg(n1,k1, n2,k2, e(-n3),k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?,k3?, n4?neg_,k4?) = Vgggg(n1,k1, n2,k2, n3,k3, e(-n4),k4);
id Vgggg(n1?pos_,k1?, n2?,k2?, n3?,k3?, n4?,k4?) = Vgggg(i(n1),k1, n2,k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?pos_,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1,k1, i(n2),k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?pos_,k3?, n4?,k4?) = Vgggg(n1,k1, n2,k2, i(n3),k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?,k3?, n4?pos_,k4?) = Vgggg(n1,k1, n2,k2, n3,k3, i(n4),k4);


* ------------------------------------------------------------------------------
*                               2.1 Color Trace
* ------------------------------------------------------------------------------

#do a={e,i} 
#do b={e,i} 
  #do P={Pu, Pd, Pux, Pdx} 
  id `P'(`a'(n1?), `b'(n2?), k1?) =
     color(d_(ci`a'[n1],ci`b'[n2]))*`P'(`a'(n1), `b'(n2), k1);
  #enddo
  #do P={Pg, Pgx} 
  id `P'(`a'(n1?), `b'(n2?), k1?) =
     color(d_(cj`a'[n1],cj`b'[n2]))*`P'(`a'(n1), `b'(n2), k1);
  #enddo

#do c={e,i} 
  id Vqqa(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?) =
     color(d_(ci`a'[n1],ci`b'[n2]))*Vqqa(`a'(n1),k1, `b'(n2),k2, `c'(n3),k3);
  id Vqqg(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?) =
     color(T(ci`a'[n1],ci`b'[n2],cj`c'[n3]))*Vqqg(`a'(n1),k1, `b'(n2),k2, `c'(n3),k3);
  id Vggg(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?) =
     color(f(cj`a'[n1],cj`b'[n2],cj`c'[n3]))*Vggg(`a'(n1),k1, `b'(n2),k2, `c'(n3),k3);
  #do d={e,i} 
  #do i=1,10
  id once Vgggg(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?, `d'(n4?),k4?) = -i_*(
     color(f(cj`a'[n1],cj`b'[n2],cj`i')*f(cj`c'[n3],cj`d'[n4],cj`i')) *
       num(d_(mu`a'[n1],mu`c'[n3])*d_(mu`b'[n2],mu`d'[n4]) - d_(mu`a'[n1],mu`d'[n4])*d_(mu`b'[n2],mu`c'[n3])) +
     color(f(cj`a'[n1],cj`c'[n3],cj`i')*f(cj`b'[n2],cj`d'[n4],cj`i')) * 
       num(d_(mu`a'[n1],mu`b'[n2])*d_(mu`c'[n3],mu`d'[n4]) - d_(mu`a'[n1],mu`d'[n4])*d_(mu`b'[n2],mu`c'[n3])) +
     color(f(cj`a'[n1],cj`d'[n4],cj`i')*f(cj`b'[n2],cj`c'[n3],cj`i')) *
       num(d_(mu`a'[n1],mu`b'[n2])*d_(mu`c'[n3],mu`d'[n4]) - d_(mu`a'[n1],mu`c'[n3])*d_(mu`b'[n2],mu`d'[n4]))
  ) ;
  #enddo
#enddo
#enddo
#enddo
#enddo

repeat;
  id color(ex1?)*color(ex2?) = color(ex1*ex2);
endrepeat;

id color(ex?) = ex;
.sort
  
#call docolor;

id cA = Ca;
id cR = Cf;
id I2R = Tf;
id NA = Na;
id 1/NA = 1/Na;
*id Tf = Tf*nf;
.sort



* ------------------------------------------------------------------------------
*                               2.2 Feynman Rules
* ------------------------------------------------------------------------------
*
*  References:
*    - Itzykson, Zuber (pp. 801-802)
*    - Peskin, Schroeder (pp. 698-700)
*

*
*                                   Propagators
*
#do P={Pu,Pd}
id `P'(i(n1?), i(n2?), k1?) = i_*num(gm(i(n2),i(n1),k1)) * den(sp(k1));
#enddo
#do P={Pg}
id `P'(i(n1?), i(n2?), k1?) = -i_*num(d_(mui[n1],mui[n2])) * den(sp(k1));
#enddo

#do P={Pux,Pdx}
id `P'(e(n1?), e(n2?), k1?) = num(gm(e(n2),e(n1),k1));
#enddo
#do P={Pax,Pgx}
id `P'(e(n1?), e(n2?), k1?) = num(-d_(mue[n1],mue[n2]));
#enddo

*
*                                    Vertices
*
#do a={e,i} 
#do b={e,i} 
#do c={e,i} 
#do V={Vqqg,Vqqa}
id `V'(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?) =
   i_*num(gm(`b'(n2),`a'(n1),mu`c'[n3])) ;
#enddo
#enddo
#enddo
#enddo

#do a={e,i} 
#do b={e,i} 
#do c={e,i} 
id Vggg(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?) =
   -num(
     d_(mu`a'[n1],mu`b'[n2])*(k2(mu`c'[n3])-k1(mu`c'[n3])) +
     d_(mu`b'[n2],mu`c'[n3])*(k3(mu`a'[n1])-k2(mu`a'[n1])) +
     d_(mu`c'[n3],mu`a'[n1])*(k1(mu`b'[n2])-k3(mu`b'[n2]))) ;
#enddo
#enddo
#enddo

repeat;
*  id num(ex1?)*num(ex2?) = num(ex1*ex2);
  id num(ex1?) = ex1;
endrepeat;
.sort

*argument num;
  repeat;
  id gm(ex1?,ex2?,?arg1)*gm(ex2?,ex3?,?arg2) = gm(ex1,ex3,?arg1,?arg2);
  endrepeat;

  #do i={1,2,3,4,5}
  id once gm(ex1?,ex1?,?arg1) = gm(`i',?arg1);
  repeat;
  id gm(`i',k1?,?arg)  = g_(`i',k1) *gm(`i',?arg);
  id gm(`i',mu1?,?arg) = g_(`i',mu1)*gm(`i',?arg);
  id gm(`i') = 1;
  endrepeat;
  tracen `i';
  #enddo

id q.q = 1;
id p1.p1 = 0;
id p2.p2 = 0;
id k1.k1 = 0;
id k2.k2 = 0;
id k3.k3 = 0;
id k4.k4 = 0;
id k5.k5 = 0;
id k6.k6 = 0;
*endargument;

*Print +ss;
*.end

id p1?.p2? = sp(p1,p2);
argument;
id p1?.p2? = sp(p1,p2);
endargument;


Bracket amp,den;
.sort
Collect num;
Print +ss;
Format Mathematica;
#write <`ME2'> "(%E)", ME2
.end



id m = 4-2*ep;

id Ca = 3;
id Cf = 4/3;
id Tf = 1/2;
id Na = 8;
.sort

Bracket den;
.sort
Collect num;
.sort

#ifdef `DEBUG'
  Print +ss;
#endif
Format Mathematica;
#write <`ME2'> "(%E)", ME2

.end
