#include color.h

CF amp,ampx, color, den, num, gm, sp;
S  m,ep, NF,NA,  Ca,Cf,Na,Tf,nf;

#define N "200";
#do i=1,`N'
I cj`i'=NA;
I cii`i'=NF;
I cie`i'=NF;
I cji`i'=NA;
I cje`i'=NA;
I mu`i'=m;
I mui`i'=m;
I mue`i'=m;
#enddo
Set cii:cii1,...,cii`N';
Set cie:cie1,...,cie`N';
Set cji:cji1,...,cji`N';
Set cje:cje1,...,cje`N';
Set mui:mui1,...,mui`N';
Set mue:mue1,...,mue`N';


* Feynman rules
CF Vqqg,Vqqa,Vggg,Vgggg;
CF Pu, Pd, Pg, Pax, Pux,PUx, Pdx,PDx, Pgx;
CF Fa, Fu,FU, Fd,FD, Fg;
CF e,i;

* Momenta
V k1,...,k9;
V l1,...,l9;
V p1,p2;
V q;

* Helpers
S ex1,ex2,ex3;
S n1,...,n4;

#define DEBUG

* ------------------------------------------------------------------------------
*                                 1. Read Amplitudes
* ------------------------------------------------------------------------------

* Here, AMP and AMPx are generated with `drqgraf' with the same <in>_<out>, but one
* with '-x' option used. (That is with <in> and <out> exchanged, e.g., AMPx.in = AMP.out).

* Read AMP
#include `AMP' # Declarations
L AMP =
#do i = 1,$n
  + amp(`i')*(
  #include `AMP' # d`i'
  )
#enddo
;
.sort

* Read AMPx
#include `AMPx' # Declarations
Skip;
L AMPx =
#do i = 1,$n
  + ampx(`i')*(
  #include `AMPx' # d`i'
  )
#enddo
;
* Since AMP and AMPx are generated by QGRAF independently their indices overlap.
* That makes impossible to restore a propper order of propagators when
* both are combined into ME2. We fix this by bumping indices in AMPx.
#define DI "100"
#do F={Fa, Fu, FU, Fd, FD, Fg} 
id `F'(n1?neg_,k1?) = `F'(n1-`DI',k1);
#enddo
#do P={Pu, Pd, Pg} 
id `P'(n1?pos_, n2?,k1?) = `P'(n1+`DI',n2,k1);
id `P'(n1?, n2?pos_,k1?) = `P'(n1,n2+`DI',k1);
#enddo
#do V={Vqqa, Vqqg, Vggg} 
id `V'(n1?pos_,k1?, n2?,k2?, n3?,k3?) = `V'(n1+`DI',k1, n2,k2, n3,k3);
id `V'(n1?,k1?, n2?pos_,k2?, n3?,k3?) = `V'(n1,k1, n2+`DI',k2, n3,k3);
id `V'(n1?,k1?, n2?,k2?, n3?pos_,k3?) = `V'(n1,k1, n2,k2, n3+`DI',k3);
id `V'(n1?neg_,k1?, n2?,k2?, n3?,k3?) = `V'(n1-`DI',k1, n2,k2, n3,k3);
id `V'(n1?,k1?, n2?neg_,k2?, n3?,k3?) = `V'(n1,k1, n2-`DI',k2, n3,k3);
id `V'(n1?,k1?, n2?,k2?, n3?neg_,k3?) = `V'(n1,k1, n2,k2, n3-`DI',k3);
#enddo
id Vgggg(n1?pos_,k1?, n2?,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1+`DI',k1, n2,k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?pos_,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1,k1, n2+`DI',k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?pos_,k3?, n4?,k4?) = Vgggg(n1,k1, n2,k2, n3+`DI',k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?,k3?, n4?pos_,k4?) = Vgggg(n1,k1, n2,k2, n3,k3, n4+`DI',k4);
id Vgggg(n1?neg_,k1?, n2?,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1-`DI',k1, n2,k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?neg_,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1,k1, n2-`DI',k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?neg_,k3?, n4?,k4?) = Vgggg(n1,k1, n2,k2, n3-`DI',k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?,k3?, n4?neg_,k4?) = Vgggg(n1,k1, n2,k2, n3,k3, n4-`DI',k4);

* ------------------------------------------------------------------------------
*                             1.1 Complex Conjugate
* ------------------------------------------------------------------------------
* These propagators and vertices change sign when complex conjugates.
* We also include Vggg since f_abc is antysymmetric.
#do X={Pg,Pu,Pd, Vqqg,Vqqa,Vgggg,Vggg} 
id `X'(?args) = -`X'(?args);
#enddo
.sort

* ------------------------------------------------------------------------------
*                                 2. Build ME2
* ------------------------------------------------------------------------------
L ME2 = AMP*AMPx;
id amp(ex1?)*ampx(ex2?) = amp(ex1,ex2);
.sort
Drop AMP,AMPx;


* Connect external lines (polarization sum)
#do x={a,g,u,d} 
id F`x'(n1?even_,k1?)*F`x'(n2?odd_,k1?) = P`x'x(n1,n2,k1);
#enddo
id FU(n1?even_,k1?)*FU(n2?odd_,k1?) = Pux(n2,n1,k1);
id FD(n1?even_,k1?)*FD(n2?odd_,k1?) = Pdx(n2,n1,k1);
.sort

* Make all indices positive
#do P={Pu, Pd, Pg} 
id `P'(n1?,n2?,k1?) = `P'(i(n1),i(n2),k1);
#enddo
#do P={Pax, Pux, Pdx, Pgx} 
id `P'(n1?,n2?,k1?) = `P'(e(-n1),e(-n2),k1);
#enddo

#do V={Vqqa, Vqqg, Vggg} 
id `V'(n1?pos_,k1?, n2?,k2?, n3?,k3?) = `V'(i(n1),k1, n2,k2, n3,k3);
id `V'(n1?,k1?, n2?pos_,k2?, n3?,k3?) = `V'(n1,k1, i(n2),k2, n3,k3);
id `V'(n1?,k1?, n2?,k2?, n3?pos_,k3?) = `V'(n1,k1, n2,k2, i(n3),k3);
id `V'(n1?neg_,k1?, n2?,k2?, n3?,k3?) = `V'(e(-n1),k1, n2,k2, n3,k3);
id `V'(n1?,k1?, n2?neg_,k2?, n3?,k3?) = `V'(n1,k1, e(-n2),k2, n3,k3);
id `V'(n1?,k1?, n2?,k2?, n3?neg_,k3?) = `V'(n1,k1, n2,k2, e(-n3),k3);
#enddo
id Vgggg(n1?neg_,k1?, n2?,k2?, n3?,k3?, n4?,k4?) = Vgggg(e(-n1),k1, n2,k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?neg_,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1,k1, e(-n2),k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?neg_,k3?, n4?,k4?) = Vgggg(n1,k1, n2,k2, e(-n3),k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?,k3?, n4?neg_,k4?) = Vgggg(n1,k1, n2,k2, n3,k3, e(-n4),k4);
id Vgggg(n1?pos_,k1?, n2?,k2?, n3?,k3?, n4?,k4?) = Vgggg(i(n1),k1, n2,k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?pos_,k2?, n3?,k3?, n4?,k4?) = Vgggg(n1,k1, i(n2),k2, n3,k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?pos_,k3?, n4?,k4?) = Vgggg(n1,k1, n2,k2, i(n3),k3, n4,k4);
id Vgggg(n1?,k1?, n2?,k2?, n3?,k3?, n4?pos_,k4?) = Vgggg(n1,k1, n2,k2, n3,k3, i(n4),k4);


* ------------------------------------------------------------------------------
*                               2.1 Feynman Rules
* ------------------------------------------------------------------------------
*  References:
*    - Itzykson, Zuber (pp. 801-802)
*    - Peskin, Schroeder (pp. 698-700)
*
* ------------------------------------------------------------------------------
*
*                                Polarization Sum
*                               ~~~~~~~~~~~~~~~~~~
id Pax(e(n1?), e(n2?), k1?) = num(-d_(mue[n1],mue[n2]));
id Pgx(e(n1?), e(n2?), k1?) = color(d_(cje[n1],cje[n2]))* num(-d_(mue[n1],mue[n2]));
#do Px={Pux,Pdx} 
id `Px'(e(n1?), e(n2?), k1?) = color(d_(cie[n1],cie[n2]))* num(gm(e(n2),e(n1),k1));
#enddo
*
*                                   Propagatos
*                                  ~~~~~~~~~~~~
#do P={Pu,Pd} 
id `P'(i(n1?), i(n2?), k1?) = color(d_(cii[n1],cii[n2])) * num(i_*gm(i(n2),i(n1),k1)) * den(sp(k1));
#enddo
id Pg(i(n1?), i(n2?), k1?) = color(-i_*d_(cji[n1],cji[n2])) * num(d_(mui[n1],mui[n2])) * den(sp(k1));
*
*                                    Vertices
*                                   ~~~~~~~~~~
#do a={e,i} 
#do b={e,i} 
#do c={e,i} 
  id Vqqa(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?) =
      color(d_(ci`a'[n1],ci`b'[n2]))*num(i_*gm(`b'(n2),`a'(n1),mu`c'[n3]));
  id Vqqg(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?) =
      color(T(ci`a'[n1],ci`b'[n2],cj`c'[n3]))*num(i_*gm(`b'(n2),`a'(n1),mu`c'[n3]));
  id Vggg(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?) =
      color(f(cj`a'[n1],cj`b'[n2],cj`c'[n3])) *
      num(d_(mu`a'[n1],mu`b'[n2])*(-k2(mu`c'[n3])+k1(mu`c'[n3])) +
          d_(mu`b'[n2],mu`c'[n3])*(-k3(mu`a'[n1])+k2(mu`a'[n1])) +
          d_(mu`c'[n3],mu`a'[n1])*(-k1(mu`b'[n2])+k3(mu`b'[n2])));
  #do d={e,i} 
  #do i=1,10
  id once Vgggg(`a'(n1?),k1?, `b'(n2?),k2?, `c'(n3?),k3?, `d'(n4?),k4?) =
      -i_*(
        color(f(cj`a'[n1],cj`b'[n2],cj`i')*f(cj`c'[n3],cj`d'[n4],cj`i')) *
          num(d_(mu`a'[n1],mu`c'[n3])*d_(mu`b'[n2],mu`d'[n4]) -
              d_(mu`a'[n1],mu`d'[n4])*d_(mu`b'[n2],mu`c'[n3])) +
        color(f(cj`a'[n1],cj`c'[n3],cj`i')*f(cj`b'[n2],cj`d'[n4],cj`i')) * 
          num(d_(mu`a'[n1],mu`b'[n2])*d_(mu`c'[n3],mu`d'[n4]) -
              d_(mu`a'[n1],mu`d'[n4])*d_(mu`b'[n2],mu`c'[n3])) +
        color(f(cj`a'[n1],cj`d'[n4],cj`i')*f(cj`b'[n2],cj`c'[n3],cj`i')) *
          num(d_(mu`a'[n1],mu`b'[n2])*d_(mu`c'[n3],mu`d'[n4]) -
              d_(mu`a'[n1],mu`c'[n3])*d_(mu`b'[n2],mu`d'[n4]))
      ) ;
  #enddo
#enddo
#enddo
#enddo
#enddo

* ------------------------------------------------------------------------------
*                               2.2 Color Trace
* ------------------------------------------------------------------------------
id color(ex1?) = ex1;
.sort

#call docolor;

id cA = Ca;
id cR = Cf;
id I2R = Tf;
id NA = Na;
id 1/NA = 1/Na;
*id Tf = Tf*nf;
.sort

Bracket amp,den,num;
.sort
Collect color;
.sort



* ------------------------------------------------------------------------------
*                            2.3 Dirac Gamma Trace
* ------------------------------------------------------------------------------
id num(ex1?) = ex1;

repeat;
id gm(ex1?,ex2?,?arg1)*gm(ex2?,ex3?,?arg2) = gm(ex1,ex3,?arg1,?arg2);
endrepeat;

#do i={1,2,3,4,5}
id once gm(ex1?,ex1?,?arg1) = gm(`i',?arg1);
repeat;
  id gm(`i',k1?,?arg)  = g_(`i',k1)*gm(`i',?arg);
  id gm(`i',mu1?,?arg) = g_(`i',mu1)*gm(`i',?arg);
  id gm(`i') = 1;
endrepeat;
tracen `i';
#enddo

id q.q = 1;
id p1.p1 = 0;
id p2.p2 = 0;
id k1.k1 = 0;
id k2.k2 = 0;
id k3.k3 = 0;
id k4.k4 = 0;
id k5.k5 = 0;
id k6.k6 = 0;

id p1?.p2? = sp(p1,p2);

Bracket amp,color,den;
.sort
Collect num;
Print +ss;

* ------------------------------------------------------------------------------
*                                   3 Output
* ------------------------------------------------------------------------------
Format Mathematica;
#write <`ME2'> "(%E)", ME2
.end
